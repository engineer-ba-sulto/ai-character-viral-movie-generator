# 実装計画: AI キャラクターアニメーション React プロジェクトの移行

**ブランチ**: `001-ai-character-animation` | **日付**: 2025-10-07 | **仕様書**: [./spec.md](./spec.md)
**入力**: 機能仕様書 `/Users/macbookhiro/Desktop/Project/NextProject/ai-character-animation/specs/001-ai-character-animation/spec.md`

## 実行フロー (/plan コマンドのスコープ)

```
1. 入力パスから機能仕様書を読み込む
   → 見つからない場合: エラー "指定パスに機能仕様書がありません"
2. 技術的コンテキストを記入 (要明確化をスキャン)
   → ファイルシステム構造またはコンテキストからプロジェクトタイプを検出 (web=frontend+backend, mobile=app+api)
   → プロジェクトタイプに基づき構造決定を設定
3. 憲法ドキュメントの内容に基づき、憲法チェックセクションを記入
4. 以下の憲法チェックセクションを評価
   → 違反が存在する場合: 複雑性追跡に記録
   → 正当化が不可能な場合: エラー "アプローチをまず単純化してください"
   → 進捗追跡を更新: 初期憲法チェック
5. フェーズ0を実行 → research.md
   → 要明確化が残っている場合: エラー "不明点を解決してください"
6. フェーズ1を実行 → contracts, data-model.md, quickstart.md, エージェント固有のテンプレートファイル (例: Claude Code用`CLAUDE.md`, GitHub Copilot用`.github/copilot-instructions.md`, Gemini CLI用`GEMINI.md`, Qwen Code用`QWEN.md`, またはその他すべてのエージェント用`AGENTS.md`)
7. 憲法チェックセクションを再評価
   → 新たな違反がある場合: 設計をリファクタリングし、フェーズ1に戻る
   → 進捗追跡を更新: 設計後の憲法チェック
8. フェーズ2を計画 → タスク生成アプローチを記述 (tasks.mdは作成しない)
9. 停止 - /tasks コマンドの準備完了
```

**重要**: /plan コマンドはステップ 7 で停止します。フェーズ 2-4 は他のコマンドによって実行されます:

- フェーズ 2: /tasks コマンドが tasks.md を作成
- フェーズ 3-4: 実装の実行 (手動またはツール経由)

## 概要

この計画は、既存の `ai-character-animation-react` (Vite ベースの React アプリ) を現在の Next.js モノレポに移行する手順の概要を示します。目標は、コードベースを統一し、依存関係を一元化し、Next.js アーキテクチャを活用することです。移行には、コンポーネント、サービス、アセットの移動、新しいページルートの作成、設定のマージが含まれます。

## 技術的コンテキスト

**言語/バージョン**: TypeScript (ルートの `tsconfig.json` で定義)
**主要な依存関係**: Next.js, React, Tailwind CSS, `@google/genai`
**ストレージ**: N/A (状態はメモリ内またはコンポーネントの状態で管理)
**テスト**: Jest / React Testing Library (追加予定)
**ターゲットプラットフォーム**: Web (Next.js)
**プロジェクトタイプ**: Web アプリケーション
**パフォーマンス目標**: 既存のアプリケーションの応答性を維持する
**制約**: 移行によって既存の UI/UX に破壊的な変更を加えないこと。UI は元のアプリケーションを完全に踏襲し、視覚的な差異がないようにすること。
**規模/スコープ**: 約 10 個のコンポーネントと 1 つのサービスの移行

## 憲法チェック

_ゲート: フェーズ 0 の研究の前に合格する必要があります。フェーズ 1 の設計後に再チェックします。_

- [x] **技術スタック**: 計画は承認された技術スタックを使用しているか？ (Next.js, TypeScript, Tailwind CSS)
- [x] **ファイル/関数サイズ**: 設計は、大きすぎるファイルや関数を予測し、回避しているか？
- [x] **OOP / モジュール性**: 設計はオブジェクト指向でモジュール化されているか？
- [x] **単一責任**: コンポーネントは単一の明確な責任を持っているか？
- [x] **関心の分離**: UI、ビジネスロジック、状態の間に明確な分離があるか？
- [x] **命名と構造**: 提案されたファイル構造と命名は規約に従っているか？
- [x] **サーバーアクション**: サーバーアクションはミューテーションにのみ正しく使用されているか？ (この移行には適用されません)

## プロジェクト構造

### ドキュメント (この機能)

```
specs/[###-feature]/
├── plan.md              # このファイル (/plan コマンドの出力)
├── research.md          # フェーズ0の出力 (/plan コマンド)
├── data-model.md        # フェーズ1の出力 (/plan コマンド)
├── quickstart.md        # フェーズ1の出力 (/plan コマンド)
├── contracts/           # フェーズ1の出力 (/plan コマンド)
└── tasks.md             # フェーズ2の出力 (/tasks コマンド - /plan では作成されない)
```

### ソースコード (リポジトリルート)

```
src/
├── app/
│   └── character-animation/
│       └── page.tsx         # 移行されたアプリケーションをホストする新しいページ
├── components/              # 移行されたコンポーネントがここに配置される
│   ├── CharacterGenerator.tsx
│   ├── CharacterPreviewModal.tsx
│   ├── Header.tsx
│   ├── icons.tsx
│   ├── ImageCard.tsx
│   ├── LoadingSpinner.tsx
│   ├── SavedCharacters.tsx
│   ├── SceneCreator.tsx
│   ├── ScenePreviewModal.tsx
│   └── VideoCreator.tsx
└── utils/
    └── geminiService.ts   # 移行されたGeminiサービス
```

**構造決定**: プロジェクトは、憲法で定義されている標準の Next.js App Router 構造に従います。移行されたコンポーネントは `src/components` に直接配置され、ビジネスロジックは `src/utils` に分離されます。

## フェーズ 0: 概要と調査

1.  **上記の技術的コンテキストから不明点を抽出**:

    - 未解決の不明点はありません。すべての `要明確化` はこの計画の前に解決されました。

2.  **調査エージェントを生成して派遣**:

    - 調査は不要です。

3.  **調査結果を `research.md` に統合**:
    - 移行パスが単純であるため、さらなる調査は不要であったことを記載した `research.md` ファイルが作成されます。

**出力**: すべての要明確化が解決された `research.md`

## フェーズ 1: 設計と契約

_前提条件: research.md が完了していること_

1.  **機能仕様書からエンティティを抽出** → `data-model.md`:

    - 主要なエンティティ（キャラクター、シーン、ビデオ）は仕様書で定義されています。古いプロジェクトの既存の `types.ts` ファイルに基づいて、それらの構造とフィールドを正式に文書化するために `data-model.md` が作成されます。

2.  **機能要件から API 契約を生成**:

    - この移行の一環として、新しいバックエンド API は作成されません。`geminiService.ts` は外部の Google API と対話するため、内部契約は不要です。`contracts/` ディレクトリは作成されません。

3.  **契約から契約テストを生成**:

    - 新しい契約が定義されていないため、適用されません。

4.  **ユーザーストーリーからテストシナリオを抽出**:

    - 仕様書の受け入れシナリオに基づき、移行が成功したことを検証するための手動テスト手順を記載した `quickstart.md` が作成されます。これには、`/character-animation` ページを読み込み、キャラクターを生成し、シーンを作成し、ビデオをレンダリングする手順が含まれます。

5.  **エージェントファイルを増分更新** (O(1) 操作):
    - `.specify/scripts/bash/update-agent-context.sh cursor` を実行
      **重要**: 上記の通りに正確に実行してください。引数を追加したり削除したりしないでください。
    - 存在する場合: 現在の計画から新しい技術のみを追加
    - マーカー間の手動追加を保持
    - 最近の変更を更新 (最後の 3 つを保持)
    - トークン効率のために 150 行未満に保つ
    - リポジトリルートに出力

**出力**: `data-model.md`, `quickstart.md`, エージェント固有ファイル

## フェーズ 2: タスク計画アプローチ

_このセクションは /tasks コマンドが何をするかを記述します - /plan の実行中には実行されません_

**タスク生成戦略**:

- `.specify/templates/tasks-template.md` をベースとして読み込む
- ファイル移行計画に基づいてタスクを生成:
  - ディレクトリの作成: `src/app/character-animation`, `src/components`, `src/utils`
  - 各コンポーネントファイルを古いプロジェクトから `src/components` に移動 [P]
  - `geminiService.ts` ファイルを `src/utils` に移動 [P]
  - `types.ts` と `constants.ts` を移動 [P]
  - 新しいルートのための `page.tsx` を作成
  - 移動したファイル内のすべてのインポートパスを更新
  - 依存関係をルートの `package.json` にマージし、`bun install` を実行
  - 環境変数を設定
  - `quickstart.md` を使用してアプリケーションを手動でテスト

**順序付け戦略**:

- 最初にディレクトリを作成
- ファイルの移行は並行して実行可能
- `page.tsx` の作成はコンポーネントの移行に依存
- パスの更新はファイルの移行に依存
- 依存関係のマージとインストールは最終的なセットアップ手順

**推定出力**: `tasks.md` に 15-20 個の番号付き、順序付けされたタスク

**重要**: このフェーズは /plan コマンドではなく、/tasks コマンドによって実行されます

## フェーズ 3+: 将来の実装

_これらのフェーズは /plan コマンドのスコープ外です_

**フェーズ 3**: タスク実行 (`/tasks` コマンドが `tasks.md` を作成)
**フェーズ 4**: 実装 (憲法の原則に従って `tasks.md` を実行)
**フェーズ 5**: 検証 (テストの実行、`quickstart.md` の実行、パフォーマンス検証)

## 複雑性追跡

_憲法チェックに正当化が必要な違反がある場合にのみ記入_

| 違反 | なぜ必要か | 却下されたより単純な代替案の理由 |
| ---- | ---------- | -------------------------------- |
| N/A  | N/A        | N/A                              |

## 進捗追跡

_このチェックリストは実行フロー中に更新されます_

**フェーズステータス**:

- [x] フェーズ 0: 調査完了 (/plan コマンド)
- [x] フェーズ 1: 設計完了 (/plan コマンド)
- [x] フェーズ 2: タスク計画完了 (/plan コマンド - アプローチのみ記述)
- [ ] フェーズ 3: タスク生成済み (/tasks コマンド)
- [ ] フェーズ 4: 実装完了
- [ ] フェーズ 5: 検証合格

**ゲートステータス**:

- [x] 初期憲法チェック: 合格
- [x] 設計後の憲法チェック: 合格
- [x] すべての要明確化が解決済み
- [x] 複雑性の逸脱が文書化済み

---

_憲法 v1.0.0 に基づく - `/memory/constitution.md` を参照_
